---
layout: post
title: "ACM-ICPC 2019 Problem B : Balanced String"
tags: [알고리즘, 대회, ACM-ICPC]
comments: true
---

> ACM-ICPC 2019 Aisa Seoul National First Round  

### 문제설명  
0과 1로 이루어진 이진 문자열 0101101은 0과 1의 개수의 차이가 1 이하이다. 뿐만 아니라, 첫번째 문자를 포함하는 모든 부분 문자열 0, 01, 010, 0101, 01011, 010110, 0101101 모두 0과 1의 개수의 차이가 1 이하이다.  

이와 같이, 이진 문자열 중에서 첫번재 문자를 포함하는 모든 부분 문자열의 0과 1의 개수의 차이가 1이하인 문자열을 균형잡힌 문자열이라 부른다. 문자열 자체도 자신의 부분 문자열이다.  

양의 정수 n이 주어질 때, 길이가 n인 이진 문자열 중에서 균형잡힌 문자열의 수를 구하는 프로그램을 작성하시오.  

예를 들어, n = 3인 경우에는 010, 011, 100, 101 네 개의 문자열이 균형잡힌 문자열이다.  

입력  
입력은 표준입력을 사용한다. 첫 번째 줄에 양의 정수 n (1 ≤ n ≤ 100,000)이 주어진다.  

출력  
출력은 표준출력을 사용한다. 길이가 n인 이진 문자열 중에서 균형잡힌 문자열의 개수를 16769023로 나눈 나머지 값을 한 줄에 출력한다.  

### 접근  
이건 윤호형이 푼 거라 지금 당장은 내 머릿속에 없다; 다음에 여유 생기면 코드 분석 해보는 걸로!  

### 코드  
~~~c++
#include <cstdio>
#include <climits>

#define MOD 16769023

int main ( void ) {
    long i = 0 ;
    
    long n = 0 ;
    scanf ( "%ld" , & n ) ;

    long num_prev [ 3 ] = { 0 } ;
    long num_next [ 3 ] = { 0 , 1 , 1 } ;
    for ( i = 1 ; i < n ; i ++ ) {
        int j = 0 ;
        for ( j = 0 ; j < 3 ; j ++ ) {
            num_prev [ j ] = num_next [ j ] ;
        }
        long sum = 0 ;
        sum = num_prev [ 1 ] + num_prev [ 2 ] ;

        num_next [ 0 ] = sum % MOD ;
        num_next [ 1 ] = num_prev [ 0 ] ;
        num_next [ 2 ] = num_prev [ 0 ] ;
    }
    long sum = 0 ;
    for ( i = 0 ; i < 3 ; i ++ ) {
        sum += num_next [ i ] ;
        sum %= MOD ;
    }
    if ( sum >= MOD ) {
        sum %= MOD ;
    }
    printf ( "%ld" , sum ) ;

    return 0 ;
}
~~~