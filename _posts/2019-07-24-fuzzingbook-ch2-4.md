---
layout: post
title: "Software Testing Study CH 2-4"
tags: [Software Testing, Fuzzing, 공부]
comments: true
---

> Greybox Fuzzing

이전 장까지 Basic fuzzing, coverage, mutation-based fuzzing에 대해서 다루었다. 이번 장부터는 이 mutations를 어떻게 특정한 목표로 이끌어가는지에 대해서 이야기한다. American Fuzzy Lop(ALF)의 알고리즘을 차용하여 데모 실습이 가능하다. 

### Ingredients for Greybox Fuzzing

1. Background  

AFL은 mutation-based fuzzer이다. 즉, seed input을 조금씩 바꾸거나 두 개의 다른 input을 합쳐서 새로운 문자열을 만든다는 뜻이다. AFL은 또한 greybox fuzzer 인데 coverage-feedback을 통해 프로그램에 어떻게 더 깊이 reach 할 지 배우기 때문이다. AFL은 완전한 black-box도, white-box도 아니다. 전자가 아닌 이유는 프로그램 분석을 조금이라도 이용하기 때문이다. 후자의 경우는 AFL이 심도있는 프로그램 분석을 기반으로 작동하지 않기 때문이다. 대신 generated input의 coverage information을 주워모으는 가벼운 방식으로 작동한다. 만약 생성된 입력값이 coverage를 증가시킨다면 그것은 후의 fuzzing을 위해서 seed corpus에 추가된다.  

2. Mutator and Seed  
mutator class implementation는 insert, delete, flip 세 가지 경우의 mutation 방식 함수를 포함하고 있다. 어떤 방법으로 mutate 할 건지도 랜덤으로 선택된다.  

3. Power Schedules  
Power schedule은 fuzzing time을 seeds 사이에 균등하게 배분하는 개념이다. 그러기 위해서 seeds에서 input을 선택해서 가져올 때 seed’s energy 값에 의존한다. fuzzing이 진행되는 동안 우리는 더 가능성이 있는 (더 짧은 문자열, 더 빠른 실행속도, coverage를 더 자주 증가시키는) seed에 높은 우선순위를 두고 선택한다. 그러므로 seed는 data 뿐만 아니라 energy 값도 가진다.  

~~~python
class PowerSchedule(object):    
    def assignEnergy(self, population):
        """Assigns each seed the same energy"""
        for seed in population:
            seed.energy = 1

    def normalizedEnergy(self, population):
        """Normalize energy"""
        energy = list(map(lambda seed: seed.energy, population))
        sum_energy = sum(energy)  # Add up all values in energy
        norm_energy = list(map(lambda nrg: nrg/sum_energy, energy))
        return norm_energy
    
    def choose(self, population):
        """Choose weighted by normalized energy."""
        import numpy as np

        self.assignEnergy(population)
        norm_energy = self.normalizedEnergy(population)
        seed = np.random.choice(population, p=norm_energy)
        return seed
~~~

~~~python
population = [Seed("A"), Seed("B"), Seed("C")]
schedule = PowerSchedule()
hits = {
    "A" : 0,
    "B" : 0,
    "C" : 0
}

for i in range(10000):
    seed = schedule.choose(population)
    hits[seed.data] += 1

hits
~~~

결과  
~~~
{'A': 3372, 'B': 3319, 'C': 3309}
~~~


### Blackbox, Greybox, and Boosted Greybox Fuzzing

1. Blackbox Mutation-based Fuzzer  
mutator + power schedule의 개념을 fuzzer에 합쳐서 넣어보자. 먼저 blackbox fuzzer로 시작해볼 것이다.  
black box fuzzer이기 때문에 기본적으로 coverage information leverage를 하지 않는다. fuzz 함수는 return generated input, run 함수는 executes fuzz specified number of times를 수행한다.  

MutationFuzzer class는 initial seed, mutator, power schedule로 구성되어 있다. fuzz는 아래의 두 가지 경우로 역할이 나뉠 수 있다.   
- unfuzzed seed from the initial seeds  
- result of fuzzing a seed in the population  

후자를 handle 하는 것이 create_candidate 함수이다. population으로 부터 입력값을 랜덤하게 선택해와 mutation을 적용하는 것이다.  

MutationFuzzer Class implementatoin  
~~~python
class MutationFuzzer(Fuzzer):
    
    def __init__(self, seeds, mutator, schedule):
        self.seeds = seeds
        self.mutator = mutator
        self.schedule = schedule
        self.inputs = []
        self.reset()

    def reset(self):
        """Reset the initial population and seed index"""
        self.population = list(map(lambda x: Seed(x), self.seeds))
        self.seed_index = 0

    def create_candidate(self):
        """Returns an input generated by fuzzing a seed in the population"""
        seed = self.schedule.choose(self.population)

        # Stacking: Apply multiple mutations to generate the candidate
        candidate = seed.data
        trials = min(len(candidate), 1 << random.randint(1,5))
        for i in range(trials):
            candidate = self.mutator.mutate(candidate)
        return candidate

    def fuzz(self):
        """Returns first each seed once and then generates new inputs"""
        if self.seed_index < len(self.seeds):
            # Still seeding
            self.inp = self.seeds[self.seed_index]
            self.seed_index += 1
        else:
            # Mutating
            self.inp = self.create_candidate()
            
        self.inputs.append(self.inp)
        return self.inp
    
~~~

Black box mutation-based fuzzer의 작동 방식을 요약하면 "처음에 제공되는 initial seeds set을 fuzzing함으로써 새로운 입력값을 생성하되, 다음 seed를 선택할 때는 power schedule 방식을 도입하여 선택한다" 이다.  

2. Greybox Mutation-based Fuzzer  
Black-box fuzzer와는 반대로 greybox fuzzer는 coverage information을 활용한다. 구체적으로는, seed population에 code coverage를 증가시키는 generated input을 더해가는 방식으
로 활용한다.  

~~~python
class GreyboxFuzzer(MutationFuzzer):    
    def reset(self):
        """Reset the initial population, seed index, coverage information"""
        super().reset()
        self.coverages_seen = set()
        self.population = [] # population is filled during greybox fuzzing
           
    def run(self, runner):
        """Run function(inp) while tracking coverage.
           If we reach new coverage,
           add inp to population and its coverage to population_coverage
        """
        result, outcome = super().run(runner)
        new_coverage = frozenset(runner.coverage())
        if new_coverage not in self.coverages_seen:
            # We have new coverage
            seed = Seed(self.inp)
            seed.coverage = runner.coverage()
            self.coverages_seen.add(new_coverage)
            self.population.append(seed)

        return (result, outcome)
~~~

greyboxfuzzer class에서 run 함수는 한 번의 input만 생성한다. 그리고 새로 발견된 coverage information이 있다면 seed를 생성, population에 추가 후 coverage는 seen으로 옮겨놓는다. 위와 같은 알고리즘은 Coverage-feedback 로부터 많은 도움을 얻는다. 새로운 seeds들은 fuzzer로 하여금 프로그램의 더 깊은 코드 구역까지 갈 수 있도록 안내하는 역할을 하게 된다.  
~~~python
reybox_fuzzer.population
~~~

결과
~~~
[good, bood, baoo`N", baduoo`N", bad!uo`N"]
~~~

Greybox fuzzer에서 seeds들이 더 많은 테스팅 과정으로 fuzzer를 가이드해주는 것을 확인할 수 있는데, 위의 결과는 input good이 exception을 일으키는 input인 bad로 mutate되는 과정을 보여준다.

![Center example image](https://user-images.githubusercontent.com/35067611/61800448-fc57fc80-ae67-11e9-8214-344f93330adb.png "Center"){: .center-image}  

3. Boosted Greybox Fuzzer
Boosted greybox fuzzer는 더 많은 coverage를 약속하는 seed에게 더 많은 energy를 준다. 즉, power schedule 알고리즘을 살짝 바꾸는 것이다. generated input에 의해서 적게 exercise 되는 코드를 unusual paths 라고 하는데, 이 unusual path를 많이 exercise하는 seed가 그것이다.  

~~~python
class AFLFastSchedule(PowerSchedule): 
    def __init__(self, exponent):
        self.exponent = exponent
            
    def assignEnergy(self, population):
        """Assign exponential energy inversely proportional to path frequency"""
        for seed in population:
            seed.energy = 1 / (self.path_frequency[getPathID(seed.coverage)] ** self.exponent)
~~~
기존의 Power Schedule에서 가중치를 추가한 AFLFastSchedule 코드  

~~~python
class CountingGreyboxFuzzer(GreyboxFuzzer):
    def reset(self):
        """Reset path frequency"""
        super().reset()
        self.schedule.path_frequency = {}
    
    def run(self, runner):
        """Inform scheduler about path frequency"""
        result, outcome = super().run(runner)

        path_id = getPathID(runner.coverage())
        if not path_id in self.schedule.path_frequency:
            self.schedule.path_frequency[path_id] = 1
        else:
            self.schedule.path_frequency[path_id] += 1
            
        return(result, outcome)
~~~

즉, coverage information을 수집할 때 마다 frequency를 기록하고 assignEnergy함수에서는 그 frequency 값이 작을수록 (unusual path 일수록) 큰 가중치를 부여해주는 것.  

기존의 greybox fuzzer와 boosted greybox fuzzer의 seed energy 결과를 확인해보면 다음과 같다.  
~~~
'f2e66f5447cf94afc06f4aff3d7cf349', 0.25000, 'good'
'3e55dc120b76995e04fdeb76ef790af8', 0.25000, 'bgko?'
'e11bfcc84cfe5320d36a03abff4d8135', 0.25000, 'bao|oD?'
'ccab8793361783ff88e8cafc58ed178b', 0.25000, 'bado}oiD\x7f'
~~~
~~~
'f2e66f5447cf94afc06f4aff3d7cf349', 0.00000, 'good'
'3e55dc120b76995e04fdeb76ef790af8', 0.00000, 'bood/'
'e11bfcc84cfe5320d36a03abff4d8135', 0.00002, 'ba^noD\x0f'
'ccab8793361783ff88e8cafc58ed178b', 0.00173, 'bad\x0f'
'd5b7040bdd60ea92a98a0d715bdb7ced', 0.99825, 'bad!\x0e'
~~~
