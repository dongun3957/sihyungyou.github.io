---
layout: post
title: "Klaytn 정복기 01 : Intro"
tags: [해커톤, 블록체인, Klaytn]
comments: true
---

> Scalability, Finality, Fork  

### 2019 제주 블록체인 해커톤  
지난번에 참가한 오픈핵2019 단톡방에 제주에서 진행되는 블록체인 해커톤 홍보글이 올라왔다. 카카오에서 만든 회사 그라운드X의 블록체인 개발 플랫폼인 클레이튼을 홍보하고 이것을 이용하여 프러덕트를 만들어내는 해커톤을 진행한다는 것이었다. 일단 제주도를 공짜로 보내주고 숙식을 해결해준다는 말에 혹하여(??) 바로 투진혁(정진혁, 최진혁), 상현이와 연락하여 팀을 만들고 디자이너로 진영이까지 섭외해서 아이디어 회의와 기획서를 쓰기 시작했다.  

![Center example image](https://user-images.githubusercontent.com/35067611/66627476-cc362380-ec36-11e9-8a1c-89364a112b93.jpg "Center"){: .center-image}  

이 해커톤은 한 팀이 최대 5명까지 구성하여 참가할 수 있으며 블록체인 기술 및 탈중앙화 서비스 개발에 관심이 있는 사람이라면 누구나 참가할 수 있다. 주제는 그라운드X 블록체인 플랫폼 클레이튼을 활용하여 다음의 세 가지 중 하나로 선택할 수 있다 : 
- 금융거래/자산관리  
- 에너지/환경  
- DID(Decentralized Identifier)  

더 자세한 내용은 [제주블록체인해커톤2019](http://jjbw.io/)에서 확인할 수 있다.  

확실히 우리 다섯 모두 블록체인에 문외한인지라 쉽지 않았다. 참가신청 시, 인프런 클레이튼 강의를 수강하면 가산점을 부여한다고 하기도 했고 뭔가 공부를 좀 해봐야겠다 싶어서 열심히 강의를 들었다. 짧지만 공부한 내용을 블로그에 몇 개의 포스팅을 통해 정리하려 한다. 먼저 블록체인의 일반적인 특징에 대해 정리하고 클레이튼은 그것들과 뭐가 다른지 이야기해보겠다.  

### Scalability (확장성)  
확장성이란 얼마나 많은 일을 신속히 처리할 수 있는지!를 뜻한다. 그렇다면 블록체인 기술에서 왜 scalability 가 중요할까? 확장성을 평가하는 지표는 다음과 같다.  

TPS : 1초에 처리하는 transaction 갯수  
Block interval : 블록을 완성하는데 걸리는 시간  

여기서 알 수 있는 점은 TPS가 아무리 높아도 Block interval이 길면 블록이 생성되고 완료되기까지 오래걸린다는 것이다. 예를 들어,  
비트코인 : TPS 7, Block interval 10분  
이더리움 : TPS 15-20, Block interval 15-20초  
리먄 ETH : 20 tps + 15초 => 300 transactions이 한 블록에 들어갈 것이다. 하지만 TPS가 10000이어도 block interval 10분이면 “1초에 만개를처리하지만 그 내용을 담은 블록이 완성되는데 10분이 걸린다”를 의미한다. 즉, 송금한번 하는데 10분까지 걸릴 수도 있다는 의미다..  

비트코인보다 빠르다는 이더리움의 15~20초도 사용자 입장에선 상당히 길다. 21세기에 결코 있을 수 없는 일이다!!  

그렇다면 기존의 블록체인이 왜 느린가?  
참여하는 노드가 많다고해서 더 빨라지지 않는다는 것이 블록체인의 특징이다. 우리가 보통 이용하는 웹서비스(client-server architecture)는 다량의 request를 빠르게 처리하기위해 분산시키고 서버를 더 많이 구축한다. 하지만 블록체인을 구성하는 노드는 100개 일이 들어오면 분산하지 않고 100개 일을 다 처리해야한다. 모든 노드가 분산하지 않고 같은 일을 반복하기 때문이다. 이렇게 되면 가장 퍼포먼스가 느린 노드에 맞게 하향평준화 된다 (bottleneck) 결국 한 PC와 수만대의 PC의 퍼포먼스가 다르지 않게 된다. 즉, 기존의 블록체인 네트워크는 속도가 느리고, 많은 양의 트랜잭션 처리하기에 부족하다.  

결론적으로 처리 속도를 높이기 위해서는 참여노드의 수를 제한하면 된다. 하지만 참여노드 수의 제한은 투명성의 저하를 의미한다. 이런 부분을 클레이튼은 자신만의 two-layer network 구조와 합의알고리즘의 개선을 통해 처리속도를 높이면서도 투명성을 포기하지 않았다. 이에 대한 자세한 설명은 [Klaytn 정복기 02 : 합의](https://sihyungyou.github.io/klaytn-consensus/)에 있다.  

### Finality (변경 불가능한 최종적 상태)  
블록이 Final 하다는 것은 블록에 담긴 거래 (TX)가 절대로 바뀔수 없다는 걸 보증한다는 것을 의미한다.  
TX(transaction)가 모호하지 않고 완료되었다고 믿어야하는데 비트코인, 이더리움은 이 최종성이 부족하다.  

예를 들어, 비트코인으로 비행기 표를 샀다고 하자. 이 구입에 대한 트랜잭션이 기록이 될 것이다. 단, 바로 처리되는것이아니라 완벽한 보증이아니지만 “결국 최종이 될거다” 라는 확률론적 최종성만 제공한다. 결제를 했지만 나중에 보면 안되어있을 수 있다(엥?)  

비트코인이 finality 까지 도달하는데 걸리는 시간 60분 (블록 채굴 평균시간10분 * 6번의 검증)  
이더리움은 6분 (블록 채굴 평균시간 15초 * 25번의 검증)  
(위에 확장성에서 언급한 TPS, Block interval과 관계가 있다)  

검증단계를 많이 거칠 수록 이 거래한 내용이 신뢰하기에 충분하다 라고 판명나는 건데 이걸 거칠수록 시간이 너무 오래 걸린다. 그래서 암호화폐가 상용화되기 어렵다. 결제 직후 최종성까지 가는 시간이 비정상, 비현실적이기 때문이다. 이런 측면에서 최종성은 매우 중요하다.  

Finality : TX가 변경 불가라는 합리적인 보장 받기까지 기다려야하는 시간을 측정!  
오랜 시간 기다리는 것이 비즈니스에 상당히 영향을 미치므로 빨리 처리된 finality 는 중요한 business 자산이다!!  

### Fork (분기)  
Fork는 블록의 연결이 두개 이상의 분기로 갈라지는 현상을 뜻한다.  
Fork 발생 이유는 블록체인 p2p 네트워크에서 모든 참여자들이 독립적으로 채굴할수있기 때문이다.  

작업증명(Proof of Work) 방식 : 블록체인에 블록을 추가하기 위해 문제를 품 (hash 값 찾기)   

두개의 노드에서 비슷한 시기에 풀었다고 하자. 그럼 블록의 후보자로 두 블록이 올라가고 이 때 분기가 발생하는 것이다. 예를 들어,  

내가 송금을 했다. TX 발생, TX pool로 들어간다. A, B노드에서 블록을 만들기위해 TX pool 에 있는 TX를 블록에 담는다. 각자가 만든 블록을 기존의 블록체인에 추가하기 위해서 문제를 풀어야 한다. 이 때 hash값 찾는 연산 과정을 거쳐야 한다. 근데 어쩌다보니 둘다 정답을 맞췄다고 하자. 그럼 각자 다른 노드에게 풀었다고 전파를 할 것이다. 이렇게 전파를 받았을 때 어떤 노드들은 A의, 어떤 노드들은 B의 블록을 받는다. 그럼 분기가 발생한 것이다.  

![Center example image](https://user-images.githubusercontent.com/35067611/66620990-7903a700-ec1d-11e9-8212-1476ac863f62.png "Center"){: .center-image}  

세번째에서 분기가 일어났다. A노드의 블록이 보라색, B노드가 검정색이라고 하자. 전파 과정에서 보라색 받은 노드들이 "결국엔" 검정색도 받게 될 것이다. 근데 검정색이 왔을 때 안받고 무시하는데 왜냐하면 이미 내가 송금한 TX가 보라색 블록에 추가되어있기 때문이다 (동일한 TX가 포함되어있으니까)  

계속 진행돼서 C 노드가 문제를 풀고 네번째 블록을 만들었다. 근데 이 C노드는 세번째 B노드의 검정블록을 먼저 받았던 노드다. 세번째 검정블록의 부모 해쉬를 가지고 있기 때문에 검정색 라인을 타고 추가가 된다. 보라색은 받을 수가 없다. 왜냐하면 네번째 블록의 부모해쉬가 세번쨰의 보라블록이아니라 세번째의 검정블록이기 때문이다! 그럼 보라를 받은 노드들은 어떻게 되는 것인가? 보라를 버리고 세번째 검정색 블록부터 다시 시작한다 (띠용?) => 그러면 검정 체인이 길어지게 된다.  

즉, 분기 때 더 길게 형성된 라인이 다음 블록으로 인정되고 블록 체인에 추가가 된다. 이것을 longest chain rule 이라고 한다. 분기가 되고 다시 한 체인으로 합쳐지는 과정이 자연스럽게 진행 됨.  

근데 이 규칙을 악의적으로 이용할 수 있다. 내가 전체 컴퓨팅파워의 51%이상을 갖고 있다면 다른 채굴자들보다 빨리 채굴하고 더 많은 블록을 만들어낼수있다. 즉 분기가 생기면 내 라인을 계속 이어나갈수있다는 것. 내가 더 빨리 만들면 다른 블록을 기다리지 않고 분기 때 내가 만든 블록들의 라인을 이어나갈 수 있다. 즉, 전파시키지 않고 계속 내꺼를 몰래 이어나가는 것이다. 이러면 내가 코인을 현금화시켰는데 그 기록을 블록에 포함시키지 않을 수 있다. 그러고 전체 네트워크에 내 라인을 등장시켜버리면 내 라인이 더 기니까 선택이되고 인정을 받는데 사기쳤던 블록이 블록체인에 합법적으로 추가가 되는 것이다.  

이렇게 네트워크를 망가뜨리는 가능성이 있다는 점이 있다. 또한 분기 때 마다 누구 라인이 더 긴가 검증을 거쳐야 하기 때문에 finality 까지 시간이 오래 걸린다는 것이 단점이다.  

출처 : [인프런 클레이튼 강의](https://www.inflearn.com/course/%ED%81%B4%EB%A0%88%EC%9D%B4%ED%8A%BC#)  