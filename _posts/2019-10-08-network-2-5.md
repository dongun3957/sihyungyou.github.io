---
layout: post
title: "Network : CH 2-5"
tags: [한동대, 공부, 네트워크]
comments: true
---

> 2.5 P2P applications  

### P2P Properties  
P2P란 지금까지 Web, mail, DNS에서 다루었던 client-server 구조와 다른 no central control, no central database 특징을 가진 peer-to-peer 구조를 말한다. 모든 peer는 대등하며(no hierarchy) 하는 일에 따라 client가 될 수도 있고 server가 될 수도 있다. 대등하다는 것은 Peer 간의 소통이 symmetric 하다는 것을 의미한다. P2P는 먼저 한쪽에 잘 정비된 global view system이 아니기에 확장성이 좋다. 하지만 임의의 peer들이 항상 available 하지는 않다는 점, peer들이 각각 독립적이라는 점 등이 단점이다. 전자의 이유때문에 system이 고정적이지 않기도 하다 (system globally unreliable)  

### Napster : Centralized Directory  
Napster는 소리바다와 같이 완전 pure P2P는 아니다. Napster는 peer끼리 연결되면 중앙서버에 알리고 IP address, content를 등록한다. 예를 들어 Alice가 "Hey Jude"라는 노래를 듣고싶다고 query를 한다는 것은 directory server에 물어본다는 것을 의미한다. 그러면 서버는 누가 그 노래를 가졌는지 알려주고 P2P로 data request 한다. 즉 일부는 centralized(location of document is centralized), 일부는 직접 P2P(data transfer)가 섞여있는 구조다.  

Napster의 장점은 fast querying 이다. data를 누가 갖고 있는지 찾는 것이 빠르다. 단점으로는 중앙화된 시스템의 고질적 문제인 single point of failure, 그리고 scalability 문제가 있다. 마지막으로 불법이라는 점에 유의해야 한다.  

### Gnutella : Query Flooding  
Gnutella는 fully distributed P2P protocol(no central server) 이다. Data를 누가 가지고 있는지 물어보고 싶어도 물어볼 서버가 없다. 그래서 query flooding 개념이 필요한데 query를 보낼 때 자기가 아는 neighbor 에게 뿌려주는 것이다. 그 요청을 받은 다른 peer들도 역시 각자의 neighbor에게 query를 날린다. 이 과정에서 자기가 아는 모든 neighbor과 connection을 맺으면 너무 많기 때문에 몇몇만 한정적으로 한다. 이런 구조의 장점으로는 연결이 끊기지만 않는다면 언젠가는 data를 전달하거나 받을 수 있다 (reliability). 하지만 이런 점이 동시에 단점이기도 한데 connection 하나만으로도 얻을 수 있는 data인데 불필요하게 많이 만들 수도 있기 때문에 그렇다. 이것을 broadcast strom 이라고 한다. Message type으로 peer가 살아있는지 확인하는 ping/pong, data를 누가 갖고 있는지 묻고 답하는 query/query hit이 있다.  

### Gnutella : Join Operation  
![Center example image](https://user-images.githubusercontent.com/35067611/66693274-204a1200-ece2-11e9-9ecd-d93068510d93.png "Center"){: .center-image}  
위 사진을 보면 새로운 peer가 어떻게 그룹에 속하는지 알 수 있다. 먼저 server가 없는 Gnutella의 fully distributed 구조이지만 처음에는 기본적인 정보가 필요하기 때문에 always-on인 peer가 몇몇 필요하다. 그것들이 GnuCache인데 새로 등록하기를 원하는 peer가 이 캐시에게 servent list를 묻는다. 그러면 available한 servent가 누군지 캐시가 알려주고 거기로 user A가 join request를 보내면 B가 수락해준다. 그리고 나중에 C가 자신의 이웃들에게 ping을 보낸다. 이 시점에서 A와 C는 연결되어있지 않기때문에 직접적으로 A에게 ping이 가지는 않는다. 하지만 B를거쳐서 A에게도 ping이 가게되고 그 때 A와 C는 서로의 존재를 확인하고 연결을 한다.  

### Gnutella : Search  
위에서 ping/pong message type이 쓰였다면 search(data를 찾는 과정)에서는 query/query hit이 사용된다. 한 peer가 query를 날리면 그 이웃들이 상응하는 data를 갖고 있다면 바로 query hit을 날리고 없다면 자신의 이웃들에게 query를 forward해준다. 그리고 query hiy을 받아오는 과정도 이웃들을 거쳐서 최초 query를 날린 peer에게 전달하게 된다. 이 과정이 query flooding인데 이 때 broadcast storm을 막기 위해서 flooding scope을 제한시킨다.  

### Gnutella Summary  
Gnutella는 간단하다. 하지만 information discovery가 느리다 (fast querying이 아니다). 또한 TTL(limited-scope query flooding)을 사용하지 않는다면 query traffic이 상당히 무거운 편이다. 여기서 query가 전달되는 이웃의 제한된 개수를 query radius라고 한다. Gnutell는 peer끼리 traffic이 없을 때에도 TCP connection이 유지되어야 한다. 마지막으로 P2P 구조에서 정보를 제공하지는 않고 받기만 하는 free rider가 매우 많다. 실제로 47% 이상의 모든 응답은 top 1%의 peer가 제공한다.  

### Hierarchical Overlay  
이런 fully distributed P2P Gnutella와 partiallay centralized P2P Napster의 장단점을 보완하기 위해서 네트워크를 계층적으로 구성한 것이 Hierarchical Overlay이다.  
![Center example image](https://user-images.githubusercontent.com/35067611/66693386-5b991080-ece3-11e9-9660-078c89a8f1c4.png "Center"){: .center-image}  
