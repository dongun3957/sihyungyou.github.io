---
layout: post
title: "ACM-ICPC 2019 Problem J : Triangulation"
tags: [알고리즘, 대회, ACM-ICPC]
comments: true
---

> 2019 ACM-ICPC Seoul Regional  

### 문제설명  
A regular n-sided polygon P can be partitioned into n − 2 triangles by adding non-crossing line segments connecting two vertices of P. For example, a square can be partitioned into two triangles, a regular pentagon can be partitioned into three triangles, and a regular hexagon can be partitioned into four triangles. The resulting set of triangles is called a triangulation of P. There exist two or more triangulations of P if n is greater than three.  

Once a triangulation T of P is chosen, the distance between two triangles a and b in T is defined to be the number of hops crossing the borders of two adjacent triangles when you travel from a to b. Note that you must stay inside the polygon P, at any time during this travel, that is, it is not allowed to hop crossing the border of P.  

For example, the distance of a and d in the triangulation shown in Figure J.1 is three since the triangles, a, b, c, and d, should be visited to travel from a to d, and you have to hop three times crossing borders between triangles.  

![Center example image](https://user-images.githubusercontent.com/35067611/68927066-49226300-07ca-11ea-8d73-38dc048dd5a2.png "Center"){: .center-image}  

The diameter of a triangulation T is the maximum of the distances between all pairs of triangles in T. Write a program to find a triangulation of a regular n-sided polygon P whose diameter is the minimum over all possible triangulations and print its diameter.  

### 접근  

### 코드  
~~~c++
#include <cstdio>
using namespace std;

int main() {

    int n, i;
    scanf("%d", &n);
    
    long long dp[n+1];
    dp[3] = 0;
    dp[4] = 1;
    dp[5] = 2;
    dp[6] = 2;

    for(i = 7; i <= n; i++) {
        if (i%2 != 0) dp[i] = dp[(i/2)+1] + 2;
        else { dp[i] = dp[i/2] + 2; }
    }

    printf("%lld\n", dp[n]);

    return 0;
}
~~~